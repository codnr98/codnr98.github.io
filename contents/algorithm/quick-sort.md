---
date: '2023-04-05'
title: 'Quick Sort'
categories: ['algorithm', 'quick sort']
summary: 'quick sort?'
thumbnail: './quick-sort.png'
---

## quick sort

다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다.

퀵 정렬은 n개의 데이터를 정렬할때 최악의 경우 O(n^2)번의 비교를 수행하고, 평균적으로 O(n log n)번의 비교를 수행한다.

원소들 중에 같은 값이 있는 경우 값들의 정렬 이후 순서가 초기 순서와 달라질 수 있어 불안정 정렬에 속한다.

퀵 정렬은 분할 정복(divide and conquer)방법을 통해 리스트를 정한다.

1. 리스트 가운데서 하나의 원소를 고른다. 이렇게 선택 된 원소를 피벗이라고 부른다.
2. 피벗 앞에는 피벗보다 작은 원소들이 오고, 피벗 뒤에는 피벗 값 보다 큰 원소들이 위치 하도록 피벗을 기준으로 리스트를 둘로 나눈다.이 것을 분할이라고 한다. 분할이 끝나면 피벗은 더이상 움직이지 않는다.
3. 분할된 두 개의 작은 리스트에 대해 재귀(Recursion)적으로 이 과정을 반복한다. 재귀의 탈출은 리스트의 크기가 0이나 1이 될 때 까지 반복한다.

### 예제

pivot을 기준으로 좌 우로 이분화 된 리스트를 재귀적으로 반복했을 때 결국 정렬이 완성된다는 방법 론이다.

1. pivot보다 큰 값을 pivot 인덱스 보다 왼쪽에서 찾고 (큰 값 이 나타날 때까지 i index를 증가)
2. pivot보다 작은 값을 pivot 인덱스 보다 오른쪽에서 찾는다 (작은 값이 나타날 때까지 j index를 증가시키도록 한다.)
3. pivot 기준으로 값 비교가 완료되었다면 index 결과 i, j를 비교 해본다.
4. i 값이 j 값 보다 작거나 같다면 분명 pivot 을 기준으로 교환을 해야할 값이 있다는 뜻이다
5. 교환 후 i 인덱스는 증가 j 인덱스는 감소 연산한다.
6. 위 과정은 pivot을 기준으로 왼쪽으로 정렬된 list 에서는 최초 left 값이 감소된 j 보다 작다면 계속 재귀한다.
7. 마찬가지로 pivot을 기준으로 오른쪽으로 정렬된 list 에서는 최조 right 값이 증가된 i 값 보다 크다면 계속 재귀한다.

---

pivot을 정하고 pivot을 기준으로 왼쪽 끝 요소를 i, 오른쪽 끝을 j로 가정한다.

```jsx
5 - 3 - 7 - 6 - 2 - 1 - 4
p
```

i 값이 피벗값 보다 크고 j값은 피벗값 보다 작음으로 둘의 위치를 바꿔준다.

```
5 - 3 - 7 - 6 - 2 - 1 - 4
i                   j   p
1 - 3 - 7 - 6 - 2 - 5 - 4
i                   j   p
```

j 값이 피벗 값 보다 작지만 , ,i 위치의 값도 피벗값 보다 작으므로 교환하지 않는다.

```
1 - 3 - 7 - 6 - 2 - 5 - 4
    i           j       p
```

i 위치를 피벗 값 보다 큰 값이 나올 때까지 진행해 j 위치의 값과 교환한다.

```
1 - 3 - 7 - 6 - 2 - 5 - 4
        i       j       p
1 - 3 - 2 - 6 - 7 - 5 - 4
        i       j       p
```

i 위치가 j 위치보다 커지면 i 위치의 값과 피벗 값을 교환한다.

```
1 - 3 - 2 - 6 - 7 - 5 - 4
                        p
1 - 3 - 2 - 4 - 7 - 5 - 6
            p
```

피벗 값 좌우의 리스트에 대해 각각 퀵 정렬을 재귀적으로 수행한다.
