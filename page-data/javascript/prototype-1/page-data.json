{"componentChunkName":"component---src-templates-post-template-tsx","path":"/javascript/prototype-1/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>자바스크립트의 객체지향 프로그래밍</h2>\n<p>자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티타입 프로그래밍 언어이며, 그 중에서도 C++나 자바 같은 클래스 기반 개체지향 프로그래밍언어와 다르게 프로토타입 기반의 객체지향 프로그래밍 언어이다.</p>\n<p>ES6에서 클래스가 도입 되었지만 기존에 있던 프로토타입 기반의 객체지향 모델을 폐지하고 새로운 객체지향을 지원하는 것이 아닌 기존 함수로 클래스 문법을 지원하는 것이며, 기존 프로토타입 기반 패턴의 문법적 설탕이라 볼 수 있다.</p>\n<h4>추상화</h4>\n<p>다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것이다.</p>\n<h4>객체지향 프로그래밍</h4>\n<p>객체의 <em>상태</em>를 나타내는 데이터와 상태 데이터를 조작할 수 있는 <em>동작</em>을 하나의 논리적인 단위로 묶어 생각한다. <em>생태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조</em> 이때 상태를 프로퍼티, 동작을 메서드라고 부른다.</p>\n<h4>상속</h4>\n<p>어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용하는 것을 말한다.</p>\n<h2>프로토타입 객체</h2>\n<p>자바스크립트는 객체지향 프로그래밍의 상속을 구현하기 위해 프로토타입 객체를 사용한다.</p>\n<p>프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체로 다른 객체에 상속할 공유 프로퍼티와 메서드를 제공한다. 그럼 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 사용할 수 있게 된다.</p>\n<h4><code class=\"language-text\">[[Prototype]]</code></h4>\n<p>모든 객체는 <code class=\"language-text\">[[Prototype]]</code> 이라는 내부 슬롯을 가지고 있다. 이 <code class=\"language-text\">[[Prototype]]</code> 의 내부 값으로 프로토타입 객체와 null이 들어가며 <code class=\"language-text\">[[Prototype]]</code>의 내부에 들어갈 프로토타입의 객체는 객체가 생성될 때 해당 객체의 생성방식에 따라 프로토타입이 결정된다.</p>\n<h4><code class=\"language-text\">__proto__</code> 접근자 프로퍼티</h4>\n<p>모든 객체는 <code class=\"language-text\">[[Prototype]]</code>내부 슬롯에 직접 접근할 수 없지만, 접근자 프로퍼티 <code class=\"language-text\">__proto__</code> 를 사용하여 간접적으로 내부슬롯에 접근할 수 있다.</p>\n<p><code class=\"language-text\">__proto__</code> 접근자 함수인 <code class=\"language-text\">[[get]]</code>,<code class=\"language-text\">[[set]]</code> 프로퍼티 어트리뷰트로 구성되어 있으며 해당 프로퍼티 어트리뷰트를 통해 <code class=\"language-text\">[[Prototype]]</code>의 내부 값인 프로토타입을 가져오거나 새로운 프로토타입을 할당할 수 있다.</p>\n<h4><code class=\"language-text\">[[Prototype]]</code>에 <code class=\"language-text\">__proto__</code> 로 접근하는 이유</h4>\n<p>프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 잘못된 프로토타입 체인이 생기는 것을 방지하기 위해서다.</p>\n<p>만약 두개의 객체의 프로토타입이 순환 참조를 하는 프로토타입 체인이 된다면 프로토타입 체인의 종점이 존재하지 않기 때문에 프로퍼티를 찾기위해 프로토타입 체인을 검색할 때 무한루프에 빠지는 상황이 일어난다.\n이 같은 이유로 프로토타입 체인은 단방향 링크드리스트로 구현되어야 한다.</p>\n<h2>Source</h2>\n<ul>\n<li>이웅모, 모던 자바스크립트 Deep Dive, 위키북스, 2020</li>\n</ul>","frontmatter":{"title":"[JS]Prototype(1)","summary":"프로토타입 1","date":"2023.09.23.","categories":["Web","javascript","Prototype"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAvUlEQVQoz62TSQvCMBCF+/9/i6K9iDcPVehiU0EFqxcRcTlYlzQXtyedHByLVVN7+MhMmDzmDRMLpz6qxHp3eT8GBI85+ZqvglyYYsng92U6vO49nHeuJnEpN+6QF8/HLQy9GiaigZFfxzJuA6kwt/y0GwJKACrSZ5Z/sF3YYfZQbXuYDWxMMyIbsWhSfGG2fxek+flIN13ItYNk0SHkysHtEJgJvhSnIc1M2xY6L2W5YAfzu2i0h5X9lH8EH40+ezYbLIoKAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/ef837801ce15bfa80da8a2a0f36adeed/d76d2/prototype-1.png","srcSet":"/static/ef837801ce15bfa80da8a2a0f36adeed/0200d/prototype-1.png 461w,\n/static/ef837801ce15bfa80da8a2a0f36adeed/0de03/prototype-1.png 922w,\n/static/ef837801ce15bfa80da8a2a0f36adeed/d76d2/prototype-1.png 1844w","sizes":"(min-width: 1844px) 1844px, 100vw"},"sources":[{"srcSet":"/static/ef837801ce15bfa80da8a2a0f36adeed/2fbbf/prototype-1.webp 461w,\n/static/ef837801ce15bfa80da8a2a0f36adeed/96b14/prototype-1.webp 922w,\n/static/ef837801ce15bfa80da8a2a0f36adeed/2b1d1/prototype-1.webp 1844w","type":"image/webp","sizes":"(min-width: 1844px) 1844px, 100vw"}]},"width":1844,"height":1118}},"publicURL":"/static/ef837801ce15bfa80da8a2a0f36adeed/prototype-1.png"}}}}]}},"pageContext":{"slug":"/javascript/prototype-1/"}},"staticQueryHashes":[]}